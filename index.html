<!DOCTYPE HTML>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<html>
    <head>
        <style>
            body {
                margin: 0px;
                padding: 0px;
            }
        </style>

        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body data-rsssl=1>
        <div class="main">
            <canvas id="myCanvas"></canvas>
        </div>

        <div class="control-panel">
            <h3 style="font-size:2vw">Context</h3>
            <br />
            <ul id="context">
            </ul>

            <input type="text" id="var-name">
            <br />
            <input type="text"   id="list-size" size="1">
            <input type="submit" id="new-cell" value="+">
            <input type="submit" id="remove-cons" value="-">
            <input type="submit" id="new-connect" value="->">
            <br />
            <br />
            <input type="submit" id="compile" value="compile">
        </div>

        <br />
        <textarea id="lisp-code"></textarea>
        <textarea id="debug"></textarea>
        <br />

        <script src = "./script.js"></script>
        <script src = "./interpreter.js"></script>
        <script>
            const width  = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            const height = window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight;
            const UI_height = 0;//height / 3;

            let canvas = document.getElementById('myCanvas');
            canvas.width = width;
            canvas.height = height - UI_height;
            let ctx = canvas.getContext('2d');

            let cells = [
                newList(10, 50, ['lambda', 'x', 'x']),
                newList(10, 100, ['+', 'x', '2']),
            ];

            let scene = new Scene(canvas, ctx, cells);
            // A repl context for our definitions
            let global_env = std_env();
            drawContext();


            document.getElementById('var-name').onkeyup = () => {
                scene.setCellValue( document.getElementById('var-name').value );
            };

            document.getElementById('compile').onclick = () => {
                let src_cell = scene.context[ scene.selected[0] ];
                let cons_list = scene.cells.filter( c => c.type == 'list');

                // Evaluate
                const result = eval(
                    parseCells(src_cell.elems, {...new Env(), ...scene.context}),
                    global_env);

                // Output
                document.getElementById('lisp-code').value = result;

                // Re-print the context
                drawContext();
            };

            document.getElementById('new-connect').onclick = () => { scene.connecting = true; };
            document.getElementById('new-cell').onclick = () => {
                let size = parseInt( document.getElementById('list-size').value );
                let l = Array.apply(null, Array(size)).map( _ => '');
                scene.addList(10,10, l);
            }
            document.getElementById('remove-cons').onclick = () => {
                scene.removeCell( scene.selected[0] );
            }

            // listen for mouse events
            canvas.onmousedown = scene.mouseDownEvent.bind(scene);
            canvas.onmouseup = scene.mouseUpEvent.bind(scene);
            canvas.onmousemove = scene.mouseMoveEvent.bind(scene);

            canvas.addEventListener('touchstart',
                scene.touchDownEvent.bind(scene));
            canvas.addEventListener('touchend',
                scene.touchUpEvent.bind(scene));
            canvas.addEventListener('touchmove',
                scene.touchMoveEvent.bind(scene));

            // call to draw the scene initially
            scene.draw();

            let dragged_fn;

            document.ondrop = (e) => {
                if ( isInCanvas(e.clientX, e.clientY) ) {
                    const name = dragged_fn.innerHTML;
                    const f = global_env[name];
                    const empty_l = [name].concat(Array.apply(null, Array(f.length)).map( _ => ''));
                    scene.addList(e.clientX, e.clientY, empty_l);
                }
            };
            document.ondragstart = (e) => { dragged_fn = e.target; };
            document.ondragover = e => {
                if ( e.target.id == 'myCanvas' )
                    e.preventDefault();
            };

            function drawContext () {
                const ul = document.getElementById('context');
                // Clear
                ul.innerHTML = '';

                // Redraw
                Object.keys(global_env).forEach( k => {
                    const li  = document.createElement('li');
                    const div = document.createElement('div');

                    div.classList.add('li-function');
                    div.draggable = true;
                    div.appendChild( document.createTextNode(k) );
                    li.appendChild(div);
                    ul.appendChild( li );
                });
            }

            function isInCanvas (x,y) {
                const box = document.getElementById('myCanvas')
                             .getBoundingClientRect();

                if (   x > box.left && x < box.right
                    && y > box.top && y < box.bottom)
                    return true;
                else return false;
            }
        </script>
    </body>
</html>
